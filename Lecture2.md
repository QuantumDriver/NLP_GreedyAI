### 课程内容

视频编号：P10 - P17

1. 算法复杂度与主定理
2. 斐波那契数列
3. 计算理论的问题
4. 案例：搭建智能客服系统

### 算法复杂度与主定理

假设我们要对一个长度为n的数组A进行排序，可以用归并排序的算法去解决。那么我们需要分析归并排序算法的时间复杂度和空间复杂度是多少，这两个属性是衡量算法优劣的重要指标。显然，归并排序是属于分治算法种类下的一种算法，它会将数组A切分成两段，再根据两段内数字互相比较从而形成新的数组。对于整个算法来说，一共进行了多次的操作，可以用Total work来表示。简化一下就是 $T(n)$, 显然可以知道 $T(n) = 2T(\frac{n}{2})+n$。$2T(\frac{n}{2})$表示子数组操作了多少次，$n$表示比较了n次。

我们根据主定理的公式：
$$
T(n) = aT(\frac{n}{b}) + f(n)
$$
主定理的三个重要推论是：

$O(n^{\log_b{a}}) > f(n)$ 或 $O(n^{\log_b{a}}) < f(n)$ ，则取大的一方作为算法的时间复杂度。如果 $O(n^{\log_b{a}}\log^{k}n) = f(n)$ 且 $ k >= 0$ ，那么时间复杂度为  $O(n^{\log_b{a}}\log^{k+1}n)$。

由于归并算法的操作是： $T(n) = 2T(\frac{n}{2})+n$。$2T(\frac{n}{2})$，那么可以知道 $ a=2,b=2$，就有 $n^{\log_2{2}}=n=f(n)$.进一步可以知道$f(n)=n=n\log^{0}n$，即 $k=0$，所以时间复杂度为$O(n^{\log_2{2}}\log^{0+1}n)=O(n\log{n})$.

### 斐波那契数列

对于数列 $ A = [1, 1, 2, 3, 5, 8, 13, 21, ...]$ ，可以知道这是一个斐波那契数列，它的规律是，从第三个数开始，每个数都等于前两个数字之和。我们假设要求第n个数字是多少，可以考虑用递归的方法来求解，Python代码如下：

```python
def fib(n):
	if n < 3:
		return 1
    return fib(n-1) + fib(n-2)
```

对于这个递归解法，我们可以用递归树的方式来刻画它的时间复杂度，以fib(6)为例，用二叉树的形式将fib(6)进行分叉，我们要求fib(5)和fib(4)，那么对于fib(5)和fib(4)显然也需要像前面那样进行二叉树分裂，直到n<3直接求得答案为止。如果我们将整颗递归树展开的话，我们的操作次数约等于 $2^0 + 2^1 + 2^2 + ... \approx 2^T-1 \gg O(2^n)$.

指数级的复杂度是难以忍受的，计算`fib(50)`可能要一整天！不能发现，这是因为递归的时候再不断的调用重复计算过的函数结果。那么，再看空间复杂度的话，递归会在考虑上下文的情况下一直进行压栈，直到最新入栈的任务被解决才会减缓内存，所以这个函数的空间复杂度是 $O(n)$.

对于 $O(2^n)$ 这个情况，由于递归的解法一直在重复的解决相同的子问题，我们可以考虑用动态规划(DP)的方式进行解决，从而实现 $O(n)$ 的时间复杂度。Python代码如下：

```python
def fib(n):
    temp = [0] * (n+1)
    temp[1] = 1
    for i in range(2,n):
        temp[i] = temp[i-1] + temp[i-2]
	return temp[-1]
```

显然，我们的列表已经把之前算出来的解"记忆"了下来，不必再用递归的方式进行重复计算，但是我们仔细思考的话会发现，其实对于一个斐波那契数而言，只需要知道它的前两个数就行，再往前数字不必记忆。那么我们可以实现 $O(1)$ 复杂度的算法，Python代码如下：

```python
def fib(n):
    a, b = 0, 1
    i = 0
    while i < n:
        a, b = b, a + b
        i += 1
    return b
```

斐波那契数列的通项公式计算速度会更快！这里给出通项公式的证明：[1](https://www.zhihu.com/question/25217301)，[2](https://www.bilibili.com/video/BV1Gb411T7Nj/?spm_id_from=333.788.videocard.0)，[3](https://www.bilibili.com/video/av45914385/)

### 计算理论的问题

什么是P问题，NP问题，NP hard问题，NP Complete问题

P就是能在多项式时间内解决的问题。

NP就是能在多项式时间验证答案正确与否的问题。显然，NP问题是包含P问题的。

NP hard就是指数级问题，难以解决。NP hard问题通常在数据较小的情况下是可以搞定的，或者是可以用近似算法去找到一个近似解，但要注意衡量出近似解和最优解之间的差距。另外还可以用量子计算机解决。

NP-complete：满足两点：1. 是NP hard的问题 2. 是NP问题

[参考资料](https://www.zhihu.com/question/27039635)

### 案例：智能客服系统

根据语料库，即Knowledge Base，包含问答对的数据资料，可以做一个问答系统。用户输入的问题，可以在问答对中找到相似度最高的问题，从而返回相应的答案。在没有数据的情况下，可以考虑用规则的方法去进行设定。

简要步骤如下：

1. 分词
2. 预处理
    - spell correction
    - stemming
    - stop-words
    - words filter
    - 同义词
    - 其他方法
3. 文本的表示(从文本到向量)
    - Boolean vector
    - count vector
    - TF-IDF vector
    - Word2Vec
    - Seq2Seq
    - 其他方法
4. 计算相似度：
    - 欧氏距离
    - 余弦距离
    - 其他距离
5. 排序
6. 异常过滤
7. 输出结果

整个客服系统，最重要的核心点在于 1. 文本表示 2. 相似度计算



